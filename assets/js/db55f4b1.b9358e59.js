"use strict";(self.webpackChunkcdp_docs=self.webpackChunkcdp_docs||[]).push([[4676],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>_});var a=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,r=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=d(n),m=l,_=u["".concat(s,".").concat(m)]||u[m]||c[m]||r;return n?a.createElement(_,o(o({ref:t},p),{},{components:n})):a.createElement(_,o({ref:t},p))}));function _(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=n.length,o=new Array(r);o[0]=m;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[u]="string"==typeof e?e:l,o[1]=i;for(var d=2;d<r;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5759:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>i,toc:()=>d});var a=n(7462),l=(n(7294),n(3905));const r={sidebar_position:4},o="Custom Codegen",i={unversionedId:"project_resources/custom_codegen_effdt",id:"project_resources/custom_codegen_effdt",title:"Custom Codegen",description:"stgucpeffdttablesgenerator.py",source:"@site/docs/project_resources/custom_codegen_effdt.md",sourceDirName:"project_resources",slug:"/project_resources/custom_codegen_effdt",permalink:"/doc/docs/project_resources/custom_codegen_effdt",draft:!1,editUrl:"https://github.com/cdp-ucsc/doc/blob/main/cdp-docs/docs/project_resources/custom_codegen_effdt.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"documentationSidebar",previous:{title:"Kimball Subsystem Inventory",permalink:"/doc/docs/project_resources/kimball_subsystem"},next:{title:"Snowflake Roles",permalink:"/doc/docs/project_resources/snowflake_roles"}},s={},d=[{value:"_stg_ucp__effdt_tables_generator.py",id:"_stg_ucp__effdt_tables_generatorpy",level:4},{value:"Python driver/generator: <code>_stg_ucp__effdt_tables_generator.py</code>",id:"python-drivergenerator-_stg_ucp__effdt_tables_generatorpy",level:2},{value:"Import packages used in the functions",id:"import-packages-used-in-the-functions",level:3},{value:"Define the get_base_tables_and_source function",id:"define-the-get_base_tables_and_source-function",level:3},{value:"Define the generate_base_model function",id:"define-the-generate_base_model-function",level:3},{value:"This is where we specify the driver that calls the functions we defined above",id:"this-is-where-we-specify-the-driver-that-calls-the-functions-we-defined-above",level:3},{value:"macros/generic_tests/",id:"macrosgeneric_tests",level:2},{value:"current_record.sql",id:"current_recordsql",level:3},{value:"future_record.sql",id:"future_recordsql",level:3},{value:"past_record.sql",id:"past_recordsql",level:3},{value:"macros/staging/",id:"macrosstaging",level:2},{value:"max_effseq.sql",id:"max_effseqsql",level:3},{value:"valid_to.sql",id:"valid_tosql",level:3},{value:"left_join_valid_to.sql",id:"left_join_valid_tosql",level:3},{value:"current_record.sql",id:"current_recordsql-1",level:3},{value:"current_record_effseq.sql",id:"current_record_effseqsql",level:3},{value:"ucsc_record.sql",id:"ucsc_recordsql",level:3},{value:"order_by_partition_cols.sql",id:"order_by_partition_colssql",level:3},{value:"macros/custom_codegen/",id:"macroscustom_codegen",level:2},{value:"stg_ucp__effdt_tables.sql",id:"stg_ucp__effdt_tablessql",level:3},{value:"macros/utils/",id:"macrosutils",level:2},{value:"custom_get_columns.sql",id:"custom_get_columnssql",level:3},{value:"Custom codegen macro: <code>stg_ucp__effdt_tables.sql</code>",id:"custom-codegen-macro-stg_ucp__effdt_tablessql",level:2},{value:"Opening declaration of the macro",id:"opening-declaration-of-the-macro",level:3},{value:"Define the source relation",id:"define-the-source-relation",level:3},{value:"Get the columns from the relation",id:"get-the-columns-from-the-relation",level:3},{value:"Sort the columns by alphabetical order if <code>alphabetize = &#39;True&#39;</code>. If false, then the columns will be ordered by its ordinal position value (can be found in the information schema).",id:"sort-the-columns-by-alphabetical-order-if-alphabetize--true-if-false-then-the-columns-will-be-ordered-by-its-ordinal-position-value-can-be-found-in-the-information-schema",level:3},{value:"Opening declaration of stg_ucp__effdt_tables variable. Everything within this declaration will be the query outputted by the macro.",id:"opening-declaration-of-stg_ucp__effdt_tables-variable-everything-within-this-declaration-will-be-the-query-outputted-by-the-macro",level:3},{value:"In the query define the partition_columns (not in the macro)",id:"in-the-query-define-the-partition_columns-not-in-the-macro",level:3},{value:"Customized source cte",id:"customized-source-cte",level:3},{value:"Call the valid_to macro in the query",id:"call-the-valid_to-macro-in-the-query",level:3},{value:"Defines the final cte. This will list all of the columns from the source relation in lowercase (source case is not preserved). It will also append all of the partition columns and the effdt column with &quot;source.&quot;.",id:"defines-the-final-cte-this-will-list-all-of-the-columns-from-the-source-relation-in-lowercase-source-case-is-not-preserved-it-will-also-append-all-of-the-partition-columns-and-the-effdt-column-with-source",level:3},{value:"Define valid_from as",id:"define-valid_from-as",level:3},{value:"Everything until the closing <code>{% endraw %}</code> is processed as plain txt",id:"everything-until-the-closing--endraw--is-processed-as-plain-txt",level:3},{value:"If effseq exists logic",id:"if-effseq-exists-logic",level:3},{value:"If effseq exists then",id:"if-effseq-exists-then",level:3},{value:"Valid_to is defined differently for records where their effseq &lt; max(effseq)",id:"valid_to-is-defined-differently-for-records-where-their-effseq--maxeffseq",level:4},{value:"Call current record effseq macro",id:"call-current-record-effseq-macro",level:4},{value:"If effseq does not exist then",id:"if-effseq-does-not-exist-then",level:3},{value:"Call ucsc_record macro",id:"call-ucsc_record-macro",level:3},{value:"Closing the {% raw %} statement",id:"closing-the--raw--statement",level:3},{value:"For the final cte",id:"for-the-final-cte",level:3},{value:"Call the left_join_valid_to macro in the query",id:"call-the-left_join_valid_to-macro-in-the-query",level:3},{value:"Select from and order by final cte",id:"select-from-and-order-by-final-cte",level:3},{value:"Closing declaration of the stg_ucp__effdt_tables variable",id:"closing-declaration-of-the-stg_ucp__effdt_tables-variable",level:3},{value:"If the macro is executed then log the info and return the variable",id:"if-the-macro-is-executed-then-log-the-info-and-return-the-variable",level:3},{value:"Example of outputted query from macro",id:"example-of-outputted-query-from-macro",level:2},{value:"Example of compiled version of the outputted query",id:"example-of-compiled-version-of-the-outputted-query",level:2}],p={toc:d},u="wrapper";function c(e){let{components:t,...n}=e;return(0,l.kt)(u,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"custom-codegen"},"Custom Codegen"),(0,l.kt)("h4",{id:"_stg_ucp__effdt_tables_generatorpy"},"_stg_ucp__effdt_tables_generator.py"),(0,l.kt)("h2",{id:"python-drivergenerator-_stg_ucp__effdt_tables_generatorpy"},"Python driver/generator: ",(0,l.kt)("inlineCode",{parentName:"h2"},"_stg_ucp__effdt_tables_generator.py")),(0,l.kt)("h3",{id:"import-packages-used-in-the-functions"},"Import packages used in the functions"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"import yaml\nimport subprocess\n")),(0,l.kt)("h3",{id:"define-the-get_base_tables_and_source-function"},"Define the get_base_tables_and_source function"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"This function will load and parse a dbt style source .yml file")),(0,l.kt)("p",null,"The function requires two inputs: the source .yml file path and a source_index. Leave the source_index as 0."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def get_base_tables_and_source(file_path, source_index):\n")),(0,l.kt)("p",null,"Preserve quotes when loading in content from the .yml file. Single and double quotes are handled behind the scenes by Python and then dbt (jinja) and the output is not always what you expect it to be. And both programs are very specific about the use of single and double quotes so this is here to help us manuever quoting."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"    yaml.preserve_quotes = True\n")),(0,l.kt)("p",null,"Open the .yml file."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"    file = open(file_path)\n")),(0,l.kt)("p",null,"Load the .yml file and grab the necessary content and store them in variables."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"    sources = yaml.load(file, Loader=yaml.FullLoader)\n\n    tables_configs = sources['sources'][source_index]['tables']\n    table_names = [item['name'] for item in tables_configs]\n    table_partition_columns = [item['partition_columns'] for item in tables_configs]\n    source_name = sources['sources'][source_index]['name']\n")),(0,l.kt)("p",null,"Specify that the function returns the source_name, table_names, and partition_columns from the .yml."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"    return source_name, table_names, table_partition_columns\n")),(0,l.kt)("h3",{id:"define-the-generate_base_model-function"},"Define the generate_base_model function"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"}," This function will generate the bash command that calls the stg_ucp__effdt_tables macro")),(0,l.kt)("p",null,"The functions requires inputs that will specific the stg_ucp__effdt_tables macro arguments."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def generate_base_model(source_name, table_name, table_partition_columns, alphabetize):\n")),(0,l.kt)("p",null,"We need to generate the partition columns in the correct format so the macro can accept the partition columns. We need to loop through the partition columns and wrap each column with a set of single and double quotations."),(0,l.kt)("p",null,"First we initialize the ",(0,l.kt)("inlineCode",{parentName:"p"},"quoted_pc")," (quoted partition column) as an empty string and get the number of partition columns (",(0,l.kt)("inlineCode",{parentName:"p"},"num_pc"),")."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'    quoted_pc = ""\n    num_pc = len(table_partition_columns)\n')),(0,l.kt)("p",null,"Then we create the string of partition_columns in the format accepted by the macro."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'    for iter in range(num_pc):\n        if iter < num_pc-1:\n            quoted_pc = quoted_pc + "\\\'\\"\\\'" + table_partition_columns[iter] + "\\\'\\"\\\'" + " , "\n        else:\n            quoted_pc = quoted_pc + "\\\'\\"\\\'" + table_partition_columns[iter] + "\\\'\\"\\\'"\n')),(0,l.kt)("p",null,"Then we piece together the bash command that will execute our macro based on the source name, table name, partition columns, and alphabetize inputs."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'    bash_command = ""\n    bash_command = bash_command + """dbt run-operation stg_ucp__effdt_tables --args "{\'source_name\': \'""" \\\n        + source_name + """\', \'table_name\': \'""" \\\n        + table_name + """\', \'partition_columns\': \'[""" \\\n        + quoted_pc + """]\', """ \\\n        + """\'alphabetize\': \'"""+ alphabetize  \\\n         + """\' }" """\n')),(0,l.kt)("p",null,"Using the ",(0,l.kt)("inlineCode",{parentName:"p"},"subprocess")," package we can execute the bash command and store the output in a variable."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"output = subprocess.getoutput(bash_command)\n")),(0,l.kt)("p",null,'Since the output from the bash command contains execution details in the first few lines, we specify a portion of the output that we want to actually save. And the portion we are interested is from the line that starts with "{% set partition_columns"} and onwards. Then we save that output to a variable.'),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"    output = subprocess.getoutput(bash_command)\n    sql_index = output.lower().find('{% set partition_columns')\n    sql_query = output[sql_index:]\n``\n\nSpecify that the function returns the output from the macro.\n```python\nreturn sql_query\n")),(0,l.kt)("h3",{id:"this-is-where-we-specify-the-driver-that-calls-the-functions-we-defined-above"},"This is where we specify the driver that calls the functions we defined above"),(0,l.kt)("p",null,"This line is a python thing and it tells python to execute the code that follows."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'if __name__ == "__main__":\n')),(0,l.kt)("p",null,"User can specify the path of the source .yml file.]"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'source_yml_path = "models/staging/ucpath/_stg_ucp__sources.yml"\n')),(0,l.kt)("p",null,"Call the ",(0,l.kt)("inlineCode",{parentName:"p"},"get_base_tables_and_source")," function to get the source name, table names, and partition columns from the .yml specified by the user."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"    source_name, table_names, table_partition_columns = get_base_tables_and_source(source_yml_path, 0)\n")),(0,l.kt)("p",null,"User friendly output to the terminal for users to view progress."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'    print("")\n    print("---------------- DRIVER ----------------")\n    print("")\n    print("Can generate stage files for the following source and tables.")\n    print("")\n    print("Source: ", source_name)\n    print("Tables: ", table_names)\n    print("Partition columns for each table: ", table_partition_columns)\n    print("")\n    print("***** User must specify table selection inside the file. LINE69 *****")\n')),(0,l.kt)("p",null,"Get the number of tables in the .yml file."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"    num_tables = len(table_names)\n")),(0,l.kt)("p",null,"User can specify the path where the generated query will be saved to."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'    stg_file_path_prefix = "analyses/test_stg_"\n')),(0,l.kt)("p",null,"User can uncomment the line that specifies what table selection they would like to execute this driver with."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"    # table_selection = 'all'\n    # table_selection = 'only_one'\n    # table_selection = 'from_x_to_y'\n")),(0,l.kt)("p",null,"User can specify the specific of their table selection."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"    only_one = 2\n    from_x = 1\n    to_y = 3\n")),(0,l.kt)("p",null,"User can uncomment the lines that specifies which alphabetize option they would like."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'    # alphabetize = "" #No\n    # alphabetize = "True" #Yes\n')),(0,l.kt)("p",null,"Based on the user selection of what table selection they would like generated there are different cases."),(0,l.kt)("p",null,"If the user wants to generate all tables in the .yml file"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"    if table_selection == 'all':\n\n        for table_number in range(num_tables):\n")),(0,l.kt)("p",null,"If the user wants to only generate one table from the .yml file"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"    elif table_selection == 'only_one':\n")),(0,l.kt)("p",null,"If the user wants to generate a range of tables from the .yml file"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"elif table_selection == 'from_x_to_y':\n        for table_number in range(from_x, to_y+1):\n")),(0,l.kt)("p",null,"The following code is the same for each table selection option but just slightly modified to accommodate each option."),(0,l.kt)("p",null,"User friendly output for users to view progress."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'            print("")\n            print("------ GENERATING...")\n            print("")\n            print(f\'The table, {table_names[table_number]}, with partition columns, {table_partition_columns[table_number]}, has been staged here: \')\n\n')),(0,l.kt)("p",null,"Call the ",(0,l.kt)("inlineCode",{parentName:"p"},"generate_base_model")," function and save output to a variable."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"            query  = generate_base_model(source_name, table_names[table_number], table_partition_columns[table_number], alphabetize)\n")),(0,l.kt)("p",null,"Specify where to save the outputted query based on source and table name."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"            stg_file_path = stg_file_path_prefix + source_name + \"__\" + table_names[table_number] + '.sql'\n")),(0,l.kt)("p",null,"Print it for the user."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"            print(stg_file_path)\n")),(0,l.kt)("p",null,"Open the file and write in the outputted query. If the file does not exist this will create the file and then write in the query. If the file does exist this will overwrite all the content that already exists with the new content. (So be careful!!)"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"            with open(stg_file_path, 'w+') as f:\n                                data = f.read()\n                                f.seek(0)\n                                f.write(query)\n                                f.truncate()\n                                f.close()\n")),(0,l.kt)("p",null,"User friendly output for users to view progress."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},'            print("")\n            print("---------------- GENERATION COMPLETE ----------------")\n            print("")\n')),(0,l.kt)("h1",{id:"dbt-pilotmacros"},"dbt-pilot/macros/"),(0,l.kt)("h2",{id:"macrosgeneric_tests"},"macros/generic_tests/"),(0,l.kt)("h3",{id:"current_recordsql"},"current_record.sql"),(0,l.kt)("p",null,"Apply at: column level \\\nFollowing columns must exist in the model: valid_from, valid_to, current_record_desc"),(0,l.kt)("p",null,"Description:\nThis test checks all current records for any records where ",(0,l.kt)("inlineCode",{parentName:"p"},"valid_from")," is greater than system date (future) or ",(0,l.kt)("inlineCode",{parentName:"p"},"valid_to")," is less than system date (past)."),(0,l.kt)("p",null,"Note, this can be applied to non-effective sequenced data sets and effective sequenced data sets. However, for effective sequenced data sets this test will not check if the ",(0,l.kt)("inlineCode",{parentName:"p"},"last_rcd_of_effdt = Y")," condition is satisfied. (This feature will be added.)"),(0,l.kt)("p",null,"Example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"version: 2\n\nmodels:\n\n  - name: [enter_model_name]\n    tests:\n      - current_record\n")),(0,l.kt)("h3",{id:"future_recordsql"},"future_record.sql"),(0,l.kt)("p",null,"Apply at: column level \\\nFollowing columns must exist in the model: valid_from, current_record_desc"),(0,l.kt)("p",null,"Description:\nThis test checks all future records for any records where ",(0,l.kt)("inlineCode",{parentName:"p"},"valid_from")," is less than or equal to system date system date (not-future)."),(0,l.kt)("p",null,"Note, can be applied to non-effective sequenced data sets and effective sequenced data sets. However, there is nothing checking the value of ",(0,l.kt)("inlineCode",{parentName:"p"},"last_rcd_of_effdt"),"."),(0,l.kt)("p",null,"Example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"version: 2\n\nmodels:\n\n  - name: [enter_model_name]\n    tests:\n      - future_record\n")),(0,l.kt)("h3",{id:"past_recordsql"},"past_record.sql"),(0,l.kt)("p",null,"Apply at: column level \\\nFollowing columns must exist in the model: valid_from, current_record_desc"),(0,l.kt)("p",null,"Description:\nThis test checks all future records for any records where ",(0,l.kt)("inlineCode",{parentName:"p"},"valid_from")," is less than or equal to system date system date (not-future)."),(0,l.kt)("p",null,"Note, can be applied to non-effective sequenced data sets and effective sequenced data sets. For effective sequenced data sets, this test will check if the 'last_rcd_of_effdt = N` condition is satisfied."),(0,l.kt)("p",null,"Example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"version: 2\n\nmodels:\n\n  - name: [enter_model_name]\n    tests:\n      - past_record\n")),(0,l.kt)("h2",{id:"macrosstaging"},"macros/staging/"),(0,l.kt)("p",null,"Description:\nThe staging macros are created to simplify the generation of staging models. They were initially developed to stage UCPath models. Therefore, lots of the macros are not 100% dynamic; meaning they have hardcoded portions that rely on a specific set up of a stage model. "),(0,l.kt)("p",null,"For example, the staging macros assume that the import CTE for the source is called ",(0,l.kt)("inlineCode",{parentName:"p"},"source"),". "),(0,l.kt)("h3",{id:"max_effseqsql"},"max_effseq.sql"),(0,l.kt)("p",null,"Input: partition_columns \\\nOutput: max_effseq_of_effdt \\\nHard-coded: effseq, effdt"),(0,l.kt)("p",null,"Description:\nThis macro takes the ",(0,l.kt)("inlineCode",{parentName:"p"},"partition_columns")," variable and returns the column ",(0,l.kt)("inlineCode",{parentName:"p"},"max_effseq_of_effdt"),". The marco applies the ",(0,l.kt)("inlineCode",{parentName:"p"},"max()")," window function over the partition of ",(0,l.kt)("inlineCode",{parentName:"p"},"partition_columns")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"effdt")," column to the ",(0,l.kt)("inlineCode",{parentName:"p"},"effseq")," column to identify the largest effective sequence within the partitioned data set."),(0,l.kt)("p",null,"Note, ",(0,l.kt)("inlineCode",{parentName:"p"},"max_effseq_of_effdt")," can be used to defined a ",(0,l.kt)("inlineCode",{parentName:"p"},"last_rcd_of_effdt = Y/N")," flag column."),(0,l.kt)("p",null,"Example:"),(0,l.kt)("p",null,"If ",(0,l.kt)("inlineCode",{parentName:"p"},"{% set partition_columns = ['employee', 'empl_rcd'] %}"),", then"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"employee"),(0,l.kt)("th",{parentName:"tr",align:null},"empl_rcd"),(0,l.kt)("th",{parentName:"tr",align:null},"effdt"),(0,l.kt)("th",{parentName:"tr",align:null},"effseq"),(0,l.kt)("th",{parentName:"tr",align:null},"max_effseq_of_effdt"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Logan"),(0,l.kt)("td",{parentName:"tr",align:null},"x"),(0,l.kt)("td",{parentName:"tr",align:null},"01/01/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"2"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Logan"),(0,l.kt)("td",{parentName:"tr",align:null},"x"),(0,l.kt)("td",{parentName:"tr",align:null},"01/01/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Logan"),(0,l.kt)("td",{parentName:"tr",align:null},"x"),(0,l.kt)("td",{parentName:"tr",align:null},"01/01/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"0"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Logan"),(0,l.kt)("td",{parentName:"tr",align:null},"x"),(0,l.kt)("td",{parentName:"tr",align:null},"06/06/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Logan"),(0,l.kt)("td",{parentName:"tr",align:null},"x"),(0,l.kt)("td",{parentName:"tr",align:null},"06/06/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"0"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Logan"),(0,l.kt)("td",{parentName:"tr",align:null},"x"),(0,l.kt)("td",{parentName:"tr",align:null},"09/09/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"0"),(0,l.kt)("td",{parentName:"tr",align:null},"0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Logan"),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"01/01/2021"),(0,l.kt)("td",{parentName:"tr",align:null},"2"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Logan"),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"01/01/2021"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Logan"),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"01/01/2021"),(0,l.kt)("td",{parentName:"tr",align:null},"0"),(0,l.kt)("td",{parentName:"tr",align:null},"2")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Logan"),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"06/06/2021"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Logan"),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"06/06/2021"),(0,l.kt)("td",{parentName:"tr",align:null},"0"),(0,l.kt)("td",{parentName:"tr",align:null},"1")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Logan"),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"09/09/2021"),(0,l.kt)("td",{parentName:"tr",align:null},"0"),(0,l.kt)("td",{parentName:"tr",align:null},"0")))),(0,l.kt)("p",null,"How to call macro: ",(0,l.kt)("inlineCode",{parentName:"p"},"{{ max_effseq(partition_columns) }}")),(0,l.kt)("h3",{id:"valid_tosql"},"valid_to.sql"),(0,l.kt)("p",null,"Input: partition_columns \\\nOutput: unique_partition_group_record (CTE), valid_to (CTE) \\\nHard-coded: effdt"),(0,l.kt)("p",null,"Description: This macro takes the ",(0,l.kt)("inlineCode",{parentName:"p"},"partition_columns")," variable and returns two CTEs, ",(0,l.kt)("inlineCode",{parentName:"p"},"unique_partition_group_record")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"valid_to"),". The ",(0,l.kt)("inlineCode",{parentName:"p"},"unique_partition_group_record")," groups the data by the ",(0,l.kt)("inlineCode",{parentName:"p"},"partition_columns")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"effdt"),". This CTE returns a unique record for each ",(0,l.kt)("inlineCode",{parentName:"p"},"partition_columns")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"effdt")," record combination. The ",(0,l.kt)("inlineCode",{parentName:"p"},"valid_to")," CTE derives a valid to date based on the preceding unique record's ",(0,l.kt)("inlineCode",{parentName:"p"},"valid_from")," date using a window function."),(0,l.kt)("p",null,"Note, the derived ",(0,l.kt)("inlineCode",{parentName:"p"},"valid_to")," column in the ",(0,l.kt)("inlineCode",{parentName:"p"},"valid_to")," CTE is used in the current record macros. And can be joined with the original data set using the ",(0,l.kt)("inlineCode",{parentName:"p"},"partition_columns")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"effdt")," columns as the joining key. "),(0,l.kt)("p",null,"Example:"),(0,l.kt)("p",null,"If ",(0,l.kt)("inlineCode",{parentName:"p"},"{% set partition_columns = ['employee', 'empl_rcd'] %}"),", then"),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"unique_partition_group_record")," CTE\n| employee      | empl_rcd       | effdt",(0,l.kt)("br",{parentName:"p"}),"\n","|--------|----------|------------\n| Logan  | x | 01/01/2022",(0,l.kt)("br",{parentName:"p"}),"\n","| Logan | x | 06/06/2022",(0,l.kt)("br",{parentName:"p"}),"\n","| Logan   | x | 09/09/2022",(0,l.kt)("br",{parentName:"p"}),"\n","| Logan  | y | 01/01/2021",(0,l.kt)("br",{parentName:"p"}),"\n","| Logan | y | 06/06/2021",(0,l.kt)("br",{parentName:"p"}),"\n","| Logan   | y | 09/09/2021     "),(0,l.kt)("p",null,"and ",(0,l.kt)("inlineCode",{parentName:"p"},"valid_to"),"\n| employee | empl_rcd | effdt      | valid_to",(0,l.kt)("br",{parentName:"p"}),"\n","|----------|----------|------------|------------\n| Logan    | x        | 01/01/2022 | 06/05/2022\n| Logan    | x        | 06/06/2022 | 09/08/2022\n| Logan    | x        | 09/09/2022 | 12/31/2099\n| Logan    | y        | 01/01/2021 | 06/05/2021\n| Logan    | y        | 06/06/2021 | 09/08/2021\n| Logan    | y        | 09/09/2021 | 12/31/2099 "),(0,l.kt)("p",null,"How to call macro: ",(0,l.kt)("inlineCode",{parentName:"p"},"{{ valid_to(partition_columns) }}")),(0,l.kt)("h3",{id:"left_join_valid_tosql"},"left_join_valid_to.sql"),(0,l.kt)("p",null,"Input: partition_columns \\\nOutput:  \\\nHard-coded: valid_to, source.effdt, valid_to.effdt"),(0,l.kt)("p",null,"Description: This macro left joins the ",(0,l.kt)("inlineCode",{parentName:"p"},"valid_to")," CTE from the ",(0,l.kt)("inlineCode",{parentName:"p"},"valid_to()")," macro to a CTE called ",(0,l.kt)("inlineCode",{parentName:"p"},"source"),". To provide the derived ",(0,l.kt)("inlineCode",{parentName:"p"},"valid_to")," column."),(0,l.kt)("h3",{id:"current_recordsql-1"},"current_record.sql"),(0,l.kt)("p",null,'Input: valid_from, valid_to \\\nOutput: current_record_desc, current_record\nHard-coded: var("system_date"), current, future, past'),(0,l.kt)("p",null,"Description: This macro takes in two columns, ",(0,l.kt)("inlineCode",{parentName:"p"},"valid_from")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"valid_to"),". Based on the ",(0,l.kt)("inlineCode",{parentName:"p"},"valid_from")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"valid_to")," column for a record it will derive if the record is a current, future or past record. The future record is defined as any record where the ",(0,l.kt)("inlineCode",{parentName:"p"},"valid_from")," date is greater than the system date (i.e. the record is not active yet). The past record is defined as any record where the ",(0,l.kt)("inlineCode",{parentName:"p"},"valid_to")," date is less than the system date (i.e. the record is expired). The current record is defined as any record where the system date is in the window defined from the ",(0,l.kt)("inlineCode",{parentName:"p"},"valid_from")," date and to the ",(0,l.kt)("inlineCode",{parentName:"p"},"valid_to")," date (i.e. is currently active)."),(0,l.kt)("p",null,"Note, this derivation of current, future, and past records is dependent on the assumption that the valid date windows, defined by ",(0,l.kt)("inlineCode",{parentName:"p"},"valid_from")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"valid_to"),", of records do not overlap. This assumption is ensured by how the ",(0,l.kt)("inlineCode",{parentName:"p"},"valid_to()")," macro derives ",(0,l.kt)("inlineCode",{parentName:"p"},"valid_to")," dates and that no record has the same transaction date in the source data.  Since the ",(0,l.kt)("inlineCode",{parentName:"p"},"valid_to")," date, lags the preceding valid_from date this ensure that windows will never have overlapping start and end dates. No overlapping windows ensures that there will only be one current record for a unique record."),(0,l.kt)("p",null,"Example:"),(0,l.kt)("p",null,"If ",(0,l.kt)("inlineCode",{parentName:"p"},"system_date = 10/17/2022"),", then"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"employee"),(0,l.kt)("th",{parentName:"tr",align:null},"empl_rcd"),(0,l.kt)("th",{parentName:"tr",align:null},"effdt"),(0,l.kt)("th",{parentName:"tr",align:null},"valid_from"),(0,l.kt)("th",{parentName:"tr",align:null},"valid_to"),(0,l.kt)("th",{parentName:"tr",align:null},"current_record_desc"),(0,l.kt)("th",{parentName:"tr",align:null},"current_record"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Logan"),(0,l.kt)("td",{parentName:"tr",align:null},"x"),(0,l.kt)("td",{parentName:"tr",align:null},"01/01/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"01/01/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"10/16/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"past"),(0,l.kt)("td",{parentName:"tr",align:null},"N")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Logan"),(0,l.kt)("td",{parentName:"tr",align:null},"x"),(0,l.kt)("td",{parentName:"tr",align:null},"10/17/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"10/17/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"12/30/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"current"),(0,l.kt)("td",{parentName:"tr",align:null},"Y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Logan"),(0,l.kt)("td",{parentName:"tr",align:null},"x"),(0,l.kt)("td",{parentName:"tr",align:null},"12/31/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"12/31/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"01/31/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"future"),(0,l.kt)("td",{parentName:"tr",align:null},"N")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Logan"),(0,l.kt)("td",{parentName:"tr",align:null},"x"),(0,l.kt)("td",{parentName:"tr",align:null},"02/01/2023"),(0,l.kt)("td",{parentName:"tr",align:null},"02/01/2023"),(0,l.kt)("td",{parentName:"tr",align:null},"12/31/2099"),(0,l.kt)("td",{parentName:"tr",align:null},"future"),(0,l.kt)("td",{parentName:"tr",align:null},"N")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Logan"),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"01/01/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"01/01/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"11/29/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"current"),(0,l.kt)("td",{parentName:"tr",align:null},"Y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Logan"),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"11/30/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"11/30/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"12/31/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"future"),(0,l.kt)("td",{parentName:"tr",align:null},"N")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Logan"),(0,l.kt)("td",{parentName:"tr",align:null},"y"),(0,l.kt)("td",{parentName:"tr",align:null},"01/01/2023"),(0,l.kt)("td",{parentName:"tr",align:null},"01/01/2023"),(0,l.kt)("td",{parentName:"tr",align:null},"12/31/2019"),(0,l.kt)("td",{parentName:"tr",align:null},"future"),(0,l.kt)("td",{parentName:"tr",align:null},"N")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Logan"),(0,l.kt)("td",{parentName:"tr",align:null},"z"),(0,l.kt)("td",{parentName:"tr",align:null},"01/01/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"01/01/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"10/17/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"current"),(0,l.kt)("td",{parentName:"tr",align:null},"Y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Logan"),(0,l.kt)("td",{parentName:"tr",align:null},"z"),(0,l.kt)("td",{parentName:"tr",align:null},"10/18/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"10/18/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"12/31/2099"),(0,l.kt)("td",{parentName:"tr",align:null},"future"),(0,l.kt)("td",{parentName:"tr",align:null},"N")))),(0,l.kt)("p",null,"How to call macro: ",(0,l.kt)("inlineCode",{parentName:"p"},"{{ current_record('valid_from', 'valid_to') }}")),(0,l.kt)("h3",{id:"current_record_effseqsql"},"current_record_effseq.sql"),(0,l.kt)("p",null,'Input: valid_from, valid_to \\\nOutput: current_record_desc, current_record\nHard-coded: var("system_date"), current, future, past, last_rcd_of_effdt'),(0,l.kt)("p",null,"Description:\nThis macro is modified version of the ",(0,l.kt)("inlineCode",{parentName:"p"},"current_record()")," macro. Is it modified to derive current records for a data set that is effective sequenced. The modification is an added condition of to the current record where you must also be the record with the largest effective sequence in addition to satisfying the original conditions. "),(0,l.kt)("p",null,"Note, this macro and the ",(0,l.kt)("inlineCode",{parentName:"p"},"current_record()")," macro can be merged into one macro."),(0,l.kt)("p",null,"Example:"),(0,l.kt)("p",null,"If ",(0,l.kt)("inlineCode",{parentName:"p"},"system_date = 10/17/2022"),", then"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"employee"),(0,l.kt)("th",{parentName:"tr",align:null},"empl_rcd"),(0,l.kt)("th",{parentName:"tr",align:null},"effdt"),(0,l.kt)("th",{parentName:"tr",align:null},"effseq"),(0,l.kt)("th",{parentName:"tr",align:null},"last_rcd_of_effdt"),(0,l.kt)("th",{parentName:"tr",align:null},"valid_from"),(0,l.kt)("th",{parentName:"tr",align:null},"valid_to"),(0,l.kt)("th",{parentName:"tr",align:null},"current_record_desc"),(0,l.kt)("th",{parentName:"tr",align:null},"current_record"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Logan"),(0,l.kt)("td",{parentName:"tr",align:null},"x"),(0,l.kt)("td",{parentName:"tr",align:null},"01/01/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"0"),(0,l.kt)("td",{parentName:"tr",align:null},"N"),(0,l.kt)("td",{parentName:"tr",align:null},"01/01/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"01/01/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"past"),(0,l.kt)("td",{parentName:"tr",align:null},"N")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Logan"),(0,l.kt)("td",{parentName:"tr",align:null},"x"),(0,l.kt)("td",{parentName:"tr",align:null},"01/01/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"N"),(0,l.kt)("td",{parentName:"tr",align:null},"01/01/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"0/01/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"past"),(0,l.kt)("td",{parentName:"tr",align:null},"N")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Logan"),(0,l.kt)("td",{parentName:"tr",align:null},"x"),(0,l.kt)("td",{parentName:"tr",align:null},"01/01/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"2"),(0,l.kt)("td",{parentName:"tr",align:null},"Y"),(0,l.kt)("td",{parentName:"tr",align:null},"01/01/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"10/16/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"past"),(0,l.kt)("td",{parentName:"tr",align:null},"N")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Logan"),(0,l.kt)("td",{parentName:"tr",align:null},"x"),(0,l.kt)("td",{parentName:"tr",align:null},"10/17/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"0"),(0,l.kt)("td",{parentName:"tr",align:null},"N"),(0,l.kt)("td",{parentName:"tr",align:null},"10/17/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"10/17/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"past"),(0,l.kt)("td",{parentName:"tr",align:null},"N")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Logan"),(0,l.kt)("td",{parentName:"tr",align:null},"x"),(0,l.kt)("td",{parentName:"tr",align:null},"10/17/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"1"),(0,l.kt)("td",{parentName:"tr",align:null},"Y"),(0,l.kt)("td",{parentName:"tr",align:null},"10/17/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"12/30/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"current"),(0,l.kt)("td",{parentName:"tr",align:null},"Y")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Logan"),(0,l.kt)("td",{parentName:"tr",align:null},"x"),(0,l.kt)("td",{parentName:"tr",align:null},"12/31/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"0"),(0,l.kt)("td",{parentName:"tr",align:null},"N"),(0,l.kt)("td",{parentName:"tr",align:null},"12/31/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"01/31/2022"),(0,l.kt)("td",{parentName:"tr",align:null},"future"),(0,l.kt)("td",{parentName:"tr",align:null},"N")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Logan"),(0,l.kt)("td",{parentName:"tr",align:null},"x"),(0,l.kt)("td",{parentName:"tr",align:null},"02/01/2023"),(0,l.kt)("td",{parentName:"tr",align:null},"0"),(0,l.kt)("td",{parentName:"tr",align:null},"N"),(0,l.kt)("td",{parentName:"tr",align:null},"02/01/2023"),(0,l.kt)("td",{parentName:"tr",align:null},"12/31/2099"),(0,l.kt)("td",{parentName:"tr",align:null},"future"),(0,l.kt)("td",{parentName:"tr",align:null},"N")))),(0,l.kt)("p",null,"How to call macro: ",(0,l.kt)("inlineCode",{parentName:"p"},"{{ current_record('valid_from', 'valid_to') }}")),(0,l.kt)("h3",{id:"ucsc_recordsql"},"ucsc_record.sql"),(0,l.kt)("p",null,"Input: partition_columns \\\nOutput: ucsc_record_desc, ucsc_record \\\nHard-coded: setid, estabid "),(0,l.kt)("p",null,"Description:\nThis macro identifies if the record is a ucsc applicable record or not by checking if setid or estabid is included in the partition columns variable and what their values are. "),(0,l.kt)("h3",{id:"order_by_partition_colssql"},"order_by_partition_cols.sql"),(0,l.kt)("p",null,"Input: partition_columns \\\nOutput: ",(0,l.kt)("em",{parentName:"p"},"script")," \\\nHard-coded: effdt"),(0,l.kt)("p",null,"Description:\nThis macro returns a order by partition columns and effdt clause."),(0,l.kt)("h2",{id:"macroscustom_codegen"},"macros/custom_codegen/"),(0,l.kt)("h3",{id:"stg_ucp__effdt_tablessql"},"stg_ucp__effdt_tables.sql"),(0,l.kt)("p",null,"Input: source_name, table_name, partition_columns, case_sensitive_cols \\\nOutput: ",(0,l.kt)("em",{parentName:"p"},"query script")," \\\nHard-coded: ",(0,l.kt)("em",{parentName:"p"},"this is intentionally a hard-coded macro")),(0,l.kt)("p",null,"Description:\nThis macro generates a staging file for UCPath effective dated tables. It is a customization of the codegen generate base model macro. "),(0,l.kt)("p",null,"Example: (BASH command) \\\n",(0,l.kt)("inlineCode",{parentName:"p"},'dbt run-operation stg_ucp__effdt_tables --args \'{"source_name": "ucpath", "table_name": "ps_compensation", "partition_columns": "[\'"\'emplid\'"\', \'"\'empl_rcd\'"\']"}\'')),(0,l.kt)("h2",{id:"macrosutils"},"macros/utils/"),(0,l.kt)("h3",{id:"custom_get_columnssql"},"custom_get_columns.sql"),(0,l.kt)("p",null,"Input: source_name, table_name, rel_type \\\nOutput: column_names \\\nHard-coded: "),(0,l.kt)("p",null,"Description:\nThis macro returns the column name of the relation inputted in a list format. The macro can return the columns of relation specified by explicit name reference, source, or ref reference. The macro relies on the ",(0,l.kt)("inlineCode",{parentName:"p"},"adapter.get_columns_in_relation")," function which gets the relation information from the information schema. Therefore, CTEs and ephemeral models are not compatible with this macro. "),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Note, ",(0,l.kt)("inlineCode",{parentName:"p"},"dbt_utils.get_filtered_columns_in_relation")," is a similar macro. There are a few differences between the two:"),(0,l.kt)("ul",{parentName:"blockquote"},(0,l.kt)("li",{parentName:"ul"},"how the custom macro and dbt-utils macro reference relations is slightly different"),(0,l.kt)("li",{parentName:"ul"},"explicit reference of a relation can be used as input in the custom and not in the dbt-util"),(0,l.kt)("li",{parentName:"ul"},"dbt-util checks for and returns error messages regarding incompatible relation types (i.e. CTE, ephemeral models) and custom does not check or return error messages but also cannot process the incompatible relation types (user will get a compilation error)"),(0,l.kt)("li",{parentName:"ul"},"dbt-utils allows you to specify columns that you would like to exclude and custom does not"))),(0,l.kt)("p",null,"Example:"),(0,l.kt)("p",null,"Using explicit rel_type: \\\n",(0,l.kt)("inlineCode",{parentName:"p"},"custom_get_columns('none', 'raw.odsprd_hcm_ods.ps_compensation', 'explicit')")),(0,l.kt)("p",null,"Using source rel_type: \\\n",(0,l.kt)("inlineCode",{parentName:"p"},"custom_get_columns('ucpath', 'ps_compensation', 'source')")),(0,l.kt)("p",null,"Using ref rel_type: \\\n",(0,l.kt)("inlineCode",{parentName:"p"},"custom_get_columns('none', 'stg_ucp__ps_compensation')")),(0,l.kt)("h1",{id:"dbt-pilotstagingstg_ucp__effdt_tablessql"},"dbt-pilot/staging/stg_ucp__effdt_tables.sql"),(0,l.kt)("h2",{id:"custom-codegen-macro-stg_ucp__effdt_tablessql"},"Custom codegen macro: ",(0,l.kt)("inlineCode",{parentName:"h2"},"stg_ucp__effdt_tables.sql")),(0,l.kt)("h3",{id:"opening-declaration-of-the-macro"},"Opening declaration of the macro"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jinja"},"{% macro stg_ucp__effdt_tables(source_name, table_name, partition_columns, alphabetize=False) %}\n")),(0,l.kt)("h3",{id:"define-the-source-relation"},"Define the source relation"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jinja"},"    {%- set source_relation = source(source_name, table_name) -%}\n")),(0,l.kt)("h3",{id:"get-the-columns-from-the-relation"},"Get the columns from the relation"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jinja"},"    {%- set columns = adapter.get_columns_in_relation(source_relation) -%}\n")),(0,l.kt)("h3",{id:"sort-the-columns-by-alphabetical-order-if-alphabetize--true-if-false-then-the-columns-will-be-ordered-by-its-ordinal-position-value-can-be-found-in-the-information-schema"},"Sort the columns by alphabetical order if ",(0,l.kt)("inlineCode",{parentName:"h3"},"alphabetize = 'True'"),". If false, then the columns will be ordered by its ordinal position value (can be found in the information schema)."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jinja"},"    {% if alphabetize %}\n        {%- set column_names=columns | map(attribute='name') | sort -%}\n    {% else %}\n        {%- set column_names=columns | map(attribute='name') -%}\n    {% endif %}\n")),(0,l.kt)("h3",{id:"opening-declaration-of-stg_ucp__effdt_tables-variable-everything-within-this-declaration-will-be-the-query-outputted-by-the-macro"},"Opening declaration of stg_ucp__effdt_tables variable. Everything within this declaration will be the query outputted by the macro."),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Query refers to the the query outputted/generated by this macro."),(0,l.kt)("pre",{parentName:"blockquote"},(0,l.kt)("code",{parentName:"pre",className:"language-jinja"},"    {%- set stg_ucp__effdt_tables -%}\n"))),(0,l.kt)("h3",{id:"in-the-query-define-the-partition_columns-not-in-the-macro"},"In the query define the partition_columns (not in the macro)"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"The contents wrapped by ",(0,l.kt)("inlineCode",{parentName:"p"},"{% raw %} {% endraw %}")," will not be processed as jinja but as plain txt. "),(0,l.kt)("pre",{parentName:"blockquote"},(0,l.kt)("code",{parentName:"pre",className:"language-jinja"},"        {% raw -%} {% set partition_columns = {% endraw %} {{ partition_columns }} {% raw -%} %} {% endraw %}\n"))),(0,l.kt)("h3",{id:"customized-source-cte"},"Customized source cte"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jinja"},"        with source as (\n\n            select * from {% raw -%} {{ source( {% endraw %} '{{ source_name }}', '{{ table_name }}' {% raw -%} ) }} {% endraw %}\n\n            where dml_ind in ('I', 'U')\n\n        ),\n")),(0,l.kt)("h3",{id:"call-the-valid_to-macro-in-the-query"},"Call the valid_to macro in the query"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jinja"},"        {% raw -%} {{ valid_to(partition_columns) }} {% endraw %}\n")),(0,l.kt)("h3",{id:"defines-the-final-cte-this-will-list-all-of-the-columns-from-the-source-relation-in-lowercase-source-case-is-not-preserved-it-will-also-append-all-of-the-partition-columns-and-the-effdt-column-with-source"},'Defines the final cte. This will list all of the columns from the source relation in lowercase (source case is not preserved). It will also append all of the partition columns and the effdt column with "source.".'),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jinja"},"        final as (\n\n            select\n\n                {%- for iter in column_names -%}\n                    {%- if iter|lower in partition_columns or iter|lower == 'effdt' %}\n                        source.{{iter | lower}},\n                    {%- else  %}\n                        {{iter | lower}},\n                    {%-endif-%}\n                {%- endfor %}\n")),(0,l.kt)("h3",{id:"define-valid_from-as"},"Define valid_from as"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jinja"},"                source.effdt as valid_from ,\n")),(0,l.kt)("h3",{id:"everything-until-the-closing--endraw--is-processed-as-plain-txt"},"Everything until the closing ",(0,l.kt)("inlineCode",{parentName:"h3"},"{% endraw %}")," is processed as plain txt"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jinja"},"                {% raw -%}\n")),(0,l.kt)("h3",{id:"if-effseq-exists-logic"},"If effseq exists logic"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jinja"},"                {% if 'EFFSEQ' in custom_get_columns( {% endraw %} '{{ source_name }}' {% raw -%} , {% endraw %} '{{ table_name }}' {% raw -%} , 'source') %}\n")),(0,l.kt)("h3",{id:"if-effseq-exists-then"},"If effseq exists then"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jinja"},"                    {{ max_effseq(partition_columns) }} \n                    case source.effseq when max_effseq_of_effdt then 'Y' else 'N' end as last_rcd_of_effdt ,\n")),(0,l.kt)("h4",{id:"valid_to-is-defined-differently-for-records-where-their-effseq--maxeffseq"},"Valid_to is defined differently for records where their effseq < max(effseq)"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jinja"},"                    case \n                        when last_rcd_of_effdt = 'Y'\n                        then valid_to.valid_to\n\n                        when last_rcd_of_effdt = 'N'\n                        then source.effdt\n                    end as valid_to ,\n")),(0,l.kt)("h4",{id:"call-current-record-effseq-macro"},"Call current record effseq macro"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jinja"},"                    {{ current_record_effseq('valid_from', 'valid_to') }}\n")),(0,l.kt)("h3",{id:"if-effseq-does-not-exist-then"},"If effseq does not exist then"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jinja"},"                {% else %}\n                    valid_to.valid_to as valid_to ,\n                    {{ current_record('valid_from', 'valid_to') }}\n\n                {% endif %}   \n")),(0,l.kt)("h3",{id:"call-ucsc_record-macro"},"Call ucsc_record macro"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jinja"},"                {{ ucsc_record(partition_columns) }}\n\n")),(0,l.kt)("h3",{id:"closing-the--raw--statement"},"Closing the {% raw %} statement"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jinja"},"                {% endraw %}\n")),(0,l.kt)("h3",{id:"for-the-final-cte"},"For the final cte"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jinja"},"        from source\n")),(0,l.kt)("h3",{id:"call-the-left_join_valid_to-macro-in-the-query"},"Call the left_join_valid_to macro in the query"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},(0,l.kt)("inlineCode",{parentName:"p"},"{{' '}}")," is the same as ",(0,l.kt)("inlineCode",{parentName:"p"},"{% raw %}{% endraw %}")),(0,l.kt)("pre",{parentName:"blockquote"},(0,l.kt)("code",{parentName:"pre",className:"language-jinja"},"        {{' {{ left_join_valid_to(partition_columns) }} '}}\n"))),(0,l.kt)("h3",{id:"select-from-and-order-by-final-cte"},"Select from and order by final cte"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jinja"},"        )\n\n        {# Custom #}\n        select * from final\n\n        {% raw %} {{ order_by_partition_cols(partition_columns) }} {% endraw %}\n\n")),(0,l.kt)("h3",{id:"closing-declaration-of-the-stg_ucp__effdt_tables-variable"},"Closing declaration of the stg_ucp__effdt_tables variable"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-jinja"},"    {% endset %}\n")),(0,l.kt)("h3",{id:"if-the-macro-is-executed-then-log-the-info-and-return-the-variable"},"If the macro is executed then log the info and return the variable"),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"This portion is straight from the codegen macro. I am not 100% sure what it accomplishes"),(0,l.kt)("pre",{parentName:"blockquote"},(0,l.kt)("code",{parentName:"pre",className:"language-jinja"},"    {% if execute %}\n"))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"    {# Custom #}\n    {{ log(stg_ucp__effdt_tables, info=True) }}\n    {# EndCustom #}\n\n    {% do return(stg_ucp__effdt_tables) %}\n\n{% endif %}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"\n### Closing declaration of the macro\n```jinja\n{% endmacro %}\n")),(0,l.kt)("h2",{id:"example-of-outputted-query-from-macro"},"Example of outputted query from macro"),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Query"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"{% set partition_columns =  ['emplid', 'empl_rcd'] %} \n\n\nwith source as (\n\n    select * from {{ source(  'ucpath', 'ps_compensation' ) }} \n\n\n    where dml_ind in ('I', 'U')\n\n\n),\n\n\n{{ valid_to(partition_columns) }} \n\n\n\nfinal as (\n\n\n    select\n                _fivetran_deleted,\n                _fivetran_id,\n                _fivetran_synced,\n                change_amt,\n                change_pct,\n                change_pts,\n                cmp_src_ind,\n                comp_effseq,\n                comp_frequency,\n                comp_pct,\n                comp_rate_points,\n                comp_ratecd,\n                comprate,\n                convert_comprt,\n                cr_bt_dtm,\n                cr_bt_nbr,\n                currency_cd,\n                dml_ind,\n                source.effdt,\n                effseq,\n                source.empl_rcd,\n                source.emplid,\n                fte_indicator,\n                manual_sw,\n                ods_vrsn_nbr,\n                rate_code_group,\n                upd_bt_dtm,\n                upd_bt_nbr,\n\n\n        -- New Objects\n        source.effdt as valid_from ,\n\n        {% if 'EFFSEQ' in custom_get_columns(  'ucpath' ,  'ps_compensation' , 'source') %}\n\n            {{ max_effseq(partition_columns) }}\n            case source.effseq when max_effseq_of_effdt then 'Y' else 'N' end as last_rcd_of_effdt ,\n\n            case\n                when last_rcd_of_effdt = 'Y'\n                then valid_to.valid_to\n\n                when last_rcd_of_effdt = 'N'\n                then source.effdt\n            end as valid_to ,\n\n            {{ current_record_effseq('valid_from', 'valid_to') }}\n\n        {% else %}\n            valid_to.valid_to as valid_to ,\n            {{ current_record('valid_from', 'valid_to') }}\n\n        {% endif %}\n\n        {{ ucsc_record(partition_columns) }}\n\n\n\n    from source\n\n        {{ left_join_valid_to(partition_columns) }}\n\n\n)\n\n\nselect * from final\n\n    {{ order_by_partition_cols(partition_columns) }}\n"))),(0,l.kt)("h2",{id:"example-of-compiled-version-of-the-outputted-query"},"Example of compiled version of the outputted query"),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Compiled Query"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"with source as (\n\n    select * from raw.odsprd_hcm_ods.ps_compensation \n\n    where dml_ind in ('I', 'U')\n\n),\n\nunique_partition_group_record as (\n    select \n        emplid ,\n        empl_rcd ,\n        effdt\n\n    from source\n\n    group by \n        emplid ,\n        empl_rcd ,\n        effdt\n\n),\n\n\nvalid_to as (\n    select \n        emplid ,\n        empl_rcd ,\n        effdt ,\n        ( lag(effdt, 1, '2100-01-01' ) over (\n                                            partition by \n                                                emplid\n                                                ,empl_rcd\n                                                order by effdt desc\n                                        )\n        - 1 ) as valid_to \n\n    from unique_partition_group_record\n\n    order by \n        emplid ,\n        empl_rcd ,\n        effdt\n\n), \n\nfinal as (\n\n\n    select\n        _fivetran_deleted,\n        _fivetran_id,\n        _fivetran_synced,\n        change_amt,\n        change_pct,\n        change_pts,\n        cmp_src_ind,\n        comp_effseq,\n        comp_frequency,\n        comp_pct,\n        comp_rate_points,\n        comp_ratecd,\n        comprate,\n        convert_comprt,\n        cr_bt_dtm,\n        cr_bt_nbr,\n        currency_cd,\n        dml_ind,\n        source.effdt,\n        effseq,\n        source.empl_rcd,\n        source.emplid,\n        fte_indicator,\n        manual_sw,\n        ods_vrsn_nbr,\n        rate_code_group,\n        upd_bt_dtm,\n        upd_bt_nbr,\n\n\n        -- New Objects\n        source.effdt as valid_from ,\n\n        max(effseq) over ( \n                partition by \n                    source.emplid ,\n                    source.empl_rcd ,\n                    source.effdt\n            ) as max_effseq_of_effdt ,\n\n        case source.effseq when max_effseq_of_effdt then 'Y' else 'N' end as last_rcd_of_effdt ,\n\n        case\n            when last_rcd_of_effdt = 'Y'\n            then valid_to.valid_to\n\n            when last_rcd_of_effdt = 'N'\n            then source.effdt\n        end as valid_to ,\n\n        case \n            when valid_from > sysdate()::date \n            then 'future'\n\n            when valid_to < sysdate()::date \n            then 'past'\n\n            when valid_to >= sysdate()::date and last_rcd_of_effdt = 'Y'\n            then 'current'\n\n            when valid_to >= sysdate()::date and last_rcd_of_effdt = 'N'\n            then 'past'\n\n            else 'verification_needed' \n        end as current_record_desc ,\n\n        case \n            when current_record_desc = 'current' \n            then 'Y'\n\n            when current_record_desc in ('future', 'past')\n            then 'N'\n\n            else 'verification_needed'\n        end as current_record\n\n    from source\n\n    left join valid_to\n        on source.emplid = valid_to.emplid\n        and source.empl_rcd = valid_to.empl_rcd\n        and source.effdt = valid_to.effdt\n\n\n)\n\n\nselect * from final\n\norder by \n    emplid\n    , empl_rcd\n    , effdt\n"))))}c.isMDXComponent=!0}}]);